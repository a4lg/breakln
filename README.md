# `breakln` : Efficient hard link breaking utility for regular files

## Why this Command?

There are multiple package managers such like `pnpm` (for JavaScript/ECMAScript)
and `uv` (for Python) that heavily utilize hard links to minimize disk usage.

However, there's a case where we need to patch *a* file for development.
`pnpm` provides its official patching mechanism but for `uv`, we need a rather
complex workaround.

This is one of the cases.  If your environment heavily depends on the hard
links and if you need to break a hard link, there's no single standard command
to *break* a hard link (note that, `unlink` does not perform what you'd expect
as this is just `rm`).

This command provides easy yet efficient hard link breaking functionality.

For instance, if the filesystem supports efficient cloning mechanism
(e.g. btrfs), this command will utilize it.  Even if not, it utilizes
efficient file-copying mechanism (i.e. the `copy_file_range` system call).


## How to run this?

```
breakln [OPTIONS...] [--] FILE...
```

If the file name can be arbitrary (may begin with `-`),
place the `--` argument before the input/output file.


## Supported Environment

This command supports Linux (kernel version 4.5 or later is expected)
with GNU libc (version 2.27 or later).


## Operating Mode (Minimum File System Disruption)

Currently, this command only implements "no temporary file" mode i.e.
the file to break a hard link is removed (while preserving the file handle)
and then the singleton version of the file with the same name is created.

This behavior minimizes disruption of the file system but if the command
fails, there's a greater chance of unintended removal of the specified file.

Future version of this command may have a separate "safer" operation mode
(which may leave a temporary file with a different name on failure).


## Safety

Functional safety is in priority but this command assumes that
the input/output file does not change while processing.
If such a change happens, various side-effects may occur:

*   The output file may have extra hard links  
    If a hard link to the input/output file is being created
    during the execution.
*   The output file may have different contents from the original file  
    If the input/output file changes during the execution
    (and this command fails to utilize native cloning mechanism).
*   The operation may fail.  
    Some are safe to revert but others *are not*.

If breaking a hard link is failed, this command will attempt to revert to
the original state before executing this command (graceful recovery).
Still, beware that such revert operation might fail as well (though unlikely
as long as `/proc/self/fd` is accessible from the command).
Those cases can be distinguished from the exit status (as explained below).

This program is designed to be harder to break files even if the program is
interrupted (e.g. terminated using `kill` command or Ctrl+C is pressed)
except when the process is killed by `SIGKILL` (e.g. `kill -9 [PID]`).


## Exit Status

The following exit values shall be returned
unless the program is interrupted by signals.

*   `0`  
    Successful completion.
*   `1`  
    Unsuccessful completion  
    (but the operation is either safely reverted to the state
    before executing this command or mostly completed except setting
    the same permission flags as the original file, not temporary`0600`).
*   `2`  
    Unsuccessful and *unsafe* completion  
    (breaking hard link is failed *and* the input/output file is lost or
    is in an unstable state).


## License

MIT License except files (and portions) automatically generated by
GNU Autotools.
